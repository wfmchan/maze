<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <title>迷宫</title>
   <style>
      table {
         border-collapse: collapse;
      }
      .road {
         background-color: pink;
      }
      td {
         width: 10px;
         height: 10px;
         border-top: 1px solid black;
         border-left: 1px solid black;
         border-right: 1px solid black;
         border-bottom: 1px solid black;
      }
      .top {
         border-top: 1px solid transparent;
      }
      .left {
         border-left: 1px solid transparent;
      }
      .right {
         border-right: 1px solid transparent;
      }
      .bottom {
         border-bottom: 1px solid transparent;
      }
   </style>
</head>

<body>
   <table id="maze"></table>
   <h3>请设定迷宫尺寸</h3>

   <p>0<input type="range" id="myRange">100</p>

   <button onclick="go()">生成迷宫</button>
   <button onclick="markroad()">走迷宫</button>
</body>

<script>


   //生成网格
   var net = () => {
      let grid = "";
      for (let i = 0; i < a; i++) {
         grid = grid + "<tr>";
         for (let j = 0; j < a; j++) {
            grid = grid + "<td id=" + i.toString().padStart(3, '0') + j.toString().padStart(3, '0') + "></td>";
         }
         grid = grid + "</tr>";
      }
      document.getElementById("maze").innerHTML = grid;
      return
   }

   class Node {    //构造节点类
      constructor(node) {//node的构造函数接受一个节点坐标数组（[node[0]，node[1]]）
         this.node = new Array();
         this.node = node;//构造节点自己
         //建立一个数组保存左节点
         this.left = new Array();
         this.left[0] = node[0];
         this.left[1] = node[1] - 1;
         //建立一个数组保存右节点
         this.right = new Array();
         this.right[0] = node[0];
         this.right[1] = node[1] + 1;
         //建立一个数组保存上节点
         this.up = new Array();
         this.up[0] = node[0] - 1;
         this.up[1] = node[1];
         //建立一个数组保存下节点
         this.down = new Array();
         this.down[0] = node[0] + 1;
         this.down[1] = node[1];
         this.children = new Array();//建立一个数组保存子节点,这个数组是个二维数组
      }
      countChildrennode() {//计算未遍历的子节点
         this.children = [];//初始化子节点
         if ((this.node[1] > 0) && (isin([this.node[0], (this.node[1] - 1)], nodes) === -
            1)) { //子节点要保证不超过边缘，还要保证该节点没被遍历过
            this.children.push(this.left); //将左子节点推入子节点数组
         }
         if ((this.node[1] + 1 < a) && (isin([this.node[0], (this.node[1] + 1)], nodes) === -1)) {
            this.children.push(this.right);
         }
         if ((this.node[0]) > 0 && (isin([this.node[0] - 1, (this.node[1])], nodes) === -1)) {
            this.children.push(this.up);
         }
         if ((this.node[0] + 1 < a) && (isin([this.node[0] + 1, (this.node[1])], nodes) === -1)) {
            this.children.push(this.down);
         }
         this.n = this.children.length; //增加属性n来保存子节点个数。
      }
   }

   var nodes = new Array(); //建立全局污染保存已遍历的节点
   var road = new Array();//建立全局污染保存通路
   var a = document.getElementById("myRange").value;//建立全局污染保存迷宫尺寸
   var go = () => {
   a = document.getElementById("myRange").value;
      net();
      nodes = [];
      road = [];
      let firstnode = new Node([0, 0]); //建立初始节点对象。
      nodes.push(firstnode.node); //把第一个节点的坐标推入数组。
      firstnode.countChildrennode();//计算子节点数n
      for (let node = firstnode; (node.n > 0 || node !== firstnode);) {
         if (node.n > 0) {
            var direction = Math.floor(Math.random() * node.n); //根据子节点数目进行随机选择子节点
            var [...child] = node.children[direction]; //建立子节点,试了一下es6的数解构赋值...
            var newnode = new Node(child); //new出子节点
            nodes.push(child); //用全局污染保存已遍历过的节点坐标。
            newnode.father = node;//为子节点增加一个属性：父节点的指针
            newnode.countChildrennode();//计算新节点的子节点数n

            if ((child[0] + 1 == a) && (child[1] + 1 == a)) { //保存出口节点（[a-1,a-1]）的父节点，这个函数只运行一次，因为任何节点只会被生成一次。注意，这里的a是个string，所以必须用==）           
               pushfather(newnode);
            }
            //拆墙
            if ((child[0] == node.up[0]) && (child[1] == node.up[1])) {
               document.getElementById(node.node[0].toString().padStart(3, '0') + node.node[1].toString().padStart(
                  3, '0')).classList.add('top');
               document.getElementById(child[0].toString().padStart(3, '0') + child[1].toString().padStart(3, '0'))
                  .classList.add('bottom');
            }
            if ((child[0] == node.down[0]) && (child[1] == node.down[1])) {
               document.getElementById(node.node[0].toString().padStart(3, '0') + node.node[1].toString().padStart(
                  3, '0')).classList.add('bottom');
               document.getElementById(child[0].toString().padStart(3, '0') + child[1].toString().padStart(3, '0'))
                  .classList.add('top');
            }
            if ((child[0] == node.left[0]) && (child[1] == node.left[1])) {
               document.getElementById(node.node[0].toString().padStart(3, '0') + node.node[1].toString().padStart(
                  3, '0')).classList.add('left');
               document.getElementById(child[0].toString().padStart(3, '0') + child[1].toString().padStart(3, '0'))
                  .classList.add('right');
            }
            if ((child[0] == node.right[0]) && (child[1] == node.right[1])) {
               document.getElementById(node.node[0].toString().padStart(3, '0') + node.node[1].toString().padStart(
                  3, '0')).classList.add('right');
               document.getElementById(child[0].toString().padStart(3, '0') + child[1].toString().padStart(3, '0'))
                  .classList.add('left');
            }

            node = newnode;//开始新的循环
         }
         else {
            node = node.father;
            node.countChildrennode()
         }
      }
      document.getElementById('000000').classList.add('left');//出口和入口
      document.getElementById(((a - 1).toString().padStart(3, '0')) + ((a - 1).toString().padStart(3, '0'))).classList.add('right');
      return
   }
   var isin = (a, b) => { //遍历程序,判断数组a是否在二维数组b中
      if (b.length != 0) {
         for (let i = 0; i < b.length; i++) {
            if ((b[i][0] === a[0]) && (b[i][1] === a[1])) {
               return 1;
            }
         }
      }
      return -1;
   }

   var pushfather = (node) => { //用来保存一个点的所有父节点
      road.push(node.node);
      if ((node.node[0] == 0) && (node.node[1] == 0)) {
         return;
      }
      return pushfather(node.father);
   }
   var markroad = () => { //迷宫正确道路标记
      for (let i = 0; i < a; i++) {
         for (let j = 0; j < a; j++) {
            if (isin(([i, j]), road) === 1) {
               document.getElementById(i.toString().padStart(3, '0') + j.toString().padStart(3, '0')).classList.add(
                  'road');
            }
         }
      }
   }
</script>

</html>
