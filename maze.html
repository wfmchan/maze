<!DOCTYPE html>
<html>

<head>
   <meta charset="utf-8">
   <title>迷宫</title>



   <style>
      table {
         border-collapse: collapse;

      }

      .road {
         background-color: pink;
      }

      td {
         width: 10px;
         height: 10px;
         border-top: 1px solid black;
         border-left: 1px solid black;
         border-right: 1px solid black;
         border-bottom: 1px solid black;
      }

      .top {
         border-top: 1px solid transparent;
      }

      .left {
         border-left: 1px solid transparent;
      }

      .right {
         border-right: 1px solid transparent;
      }

      .bottom {
         border-bottom: 1px solid transparent;
      }
   </style>



   <script>
      //生成网格
      function net() {
         var grid = ""
         for (let i = 0; i < 45; i++) {
            grid = grid + "<tr>";

            for (let j = 0; j < 45; j++) {
               grid = grid + "<td id=" + i.toString().padStart(5, '0') + j.toString().padStart(5, '0') + "></td>";
            }
            grid = grid + "</tr>";
         }
         document.getElementById("maze").innerHTML = grid;
         
      }





      //生成迷宫
      var nodes = new Array(); //建立全局污染保存已遍历过在节点坐标。
      var road = new Array(); //建立全局污染保存迷宫正确路径
      function isin(a, b) { //遍历程序,判断数组a是否在二维数组b中
         if (b.length != 0) {
            for (let i = 0; i < b.length; i++) {
               if ((b[i][0] === a[0]) && (b[i][1] === a[1])) {
                  return 1;
               }
            }
         }
         return -1;
      }
      //构造节点类，坐标（node[0]，node[1])
      function Node(node) {
         //构造节点自己
         this.node = new Array();
         this.node = node;
         //建立一个数组保存左节点
         this.left = new Array();
         this.left[0] = node[0];
         this.left[1] = node[1] - 1;
         //建立一个数组保存右节点
         this.right = new Array();
         this.right[0] = node[0];
         this.right[1] = node[1] + 1;
         //建立一个数组保存上节点
         this.up = new Array();
         this.up[0] = node[0] - 1;
         this.up[1] = node[1];
         //建立一个数组保存下节点
         this.down = new Array();
         this.down[0] = node[0] + 1;
         this.down[1] = node[1];
      }
      var firstnode = new Node([0, 0]); //建立初始节点对象。
      //console.log(firstnode.node);
      nodes.push(firstnode.node); //把第一个节点的坐标推入数组。
      //生成子节点，采取随机的深度优先遍历在方法做图转树。遍历与树生成同步进行，生成在新节点推入nodes数组,然后启动递归。直到某子节点在所有子节点都被生成过，退回父节点递归。递归出口为[0,0]。
      function go(gonode) { //别问我为什么叫gonode,随便取的。
         gonode.children = new Array(); //建立一个数组保存子节点,这个数组是个二维数组
         if ((gonode.node[1] > 0) && (isin([gonode.node[0], (gonode.node[1] - 1)], nodes) === -
               1)) { //子节点要保证不超过边缘，还要保证该节点没被遍历过
            gonode.children.push(gonode.left); //将左子节点推入子节点数组
         }
         if ((gonode.node[1] + 1 < 45) && (isin([gonode.node[0], (gonode.node[1] + 1)], nodes) === -1)) {
            gonode.children.push(gonode.right);
         }
         if ((gonode.node[0]) > 0 && (isin([gonode.node[0] - 1, (gonode.node[1])], nodes) === -1)) {
            gonode.children.push(gonode.up);
         }
         if ((gonode.node[0] + 1 < 45) && (isin([gonode.node[0] + 1, (gonode.node[1])], nodes) === -1)) {
            gonode.children.push(gonode.down);
         }
         gonode.n = gonode.children.length; //n来保存子节点个数。
         if (gonode.n > 0) {
            var direction = Math.floor(Math.random() * gonode.n); //根据子节点数目进行随机选择子节点
            var [...child] = gonode.children[direction]; //建立子节点数组,试了一下es6的新特性...
            var newnode = new Node(child); //new出子节点
            nodes.push(child); //用全局污染保存已遍历过在节点坐标。
            newnode.father = gonode;
            //console.log(child);
            //为子节点增加一个属性：父节点的指针

            //迷宫正确道路标记函数
            function pushfather(foo) { //用来保存一个点的所有父节点
               road.push(foo.node);
               if ((foo.node[0] == 0) && (foo.node[1] == 0) ){
                  console.log('road');
                  return;
               }
               pushfather(foo.father);
            }

            if ((child[0] === 44) && (child[1] === 44)) { //保存出口节点（[44,44]）的父节点，这个函数只运行一次，因为任何节点只会被生成一次。
               pushfather(newnode);
               console.log('road');
            }

            //开始拆墙
            if ((child[0] == gonode.up[0]) && (child[1] == gonode.up[1])) {
               document.getElementById(gonode.node[0].toString().padStart(5, '0') + gonode.node[1].toString().padStart(
                  5, '0')).classList.add('top');
               document.getElementById(child[0].toString().padStart(5, '0') + child[1].toString().padStart(5, '0'))
                  .classList.add('bottom');
            }
            if ((child[0] == gonode.down[0]) && (child[1] == gonode.down[1])) {
               document.getElementById(gonode.node[0].toString().padStart(5, '0') + gonode.node[1].toString().padStart(
                  5, '0')).classList.add('bottom');
               document.getElementById(child[0].toString().padStart(5, '0') + child[1].toString().padStart(5, '0'))
                  .classList.add('top');
            }
            if ((child[0] == gonode.left[0]) && (child[1] == gonode.left[1])) {
               document.getElementById(gonode.node[0].toString().padStart(5, '0') + gonode.node[1].toString().padStart(
                  5, '0')).classList.add('left');
               document.getElementById(child[0].toString().padStart(5, '0') + child[1].toString().padStart(5, '0'))
                  .classList.add('right');
            }
            if ((child[0] == gonode.right[0]) && (child[1] == gonode.right[1])) {
               document.getElementById(gonode.node[0].toString().padStart(5, '0') + gonode.node[1].toString().padStart(
                  5, '0')).classList.add('right');
               document.getElementById(child[0].toString().padStart(5, '0') + child[1].toString().padStart(5, '0'))
                  .classList.add('left');
            }
            go(newnode); //启动递归

         } else if ((gonode.node[0] != 0) || (gonode.node[1] != 0)) { //如果没有子节点需要生成，返回遍历父节点，直到[0,0]

            go(gonode.father);

         } else {
            document.getElementById('0000000000').classList.add('left');
            document.getElementById('0004400044').classList.add('right');
            nodes.splice(0, nodes.length);
            console.log('the end');
            return;
         }
      }

     function markroad() {
         for (let i = 0; i < 45; i++) {
            for (let j = 0; j < 45; j++) {
               if (isin(([i, j]), road) === 1) {
                  document.getElementById(i.toString().padStart(5, '0') + j.toString().padStart(5, '0')).classList.add(
                     'road');
               }

            }
         }
      }
      
   </script>
</head>


<body>


   <table id="maze"></table>
   <button onclick="net()">生成网格</button>
   <button onclick="go(firstnode)">生成迷宫</button>
   <button onclick="markroad()">走迷宫</button>



</body>

</html>
